{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"ParShift","text":"<p>ParShift is a python package based on Gibson's framework for the analysis of conversational sequences.</p> <p>The framework is established on the concept of participation shift, which refers to the shifting of individuals between the positions of speaker, target (addressee), and non-addressee (everyone else), in a group conversation.</p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#from-pypi","title":"From PyPI","text":"<pre><code>pip install parshift #not available yet \n</code></pre>"},{"location":"index.html#from-source","title":"From source","text":"<p>Directly using pip:</p> <pre><code>pip install git+https://github.com/bdfsaraiva/parshift.git#egg=parshift\n</code></pre> <p>Or each step at a time:</p> <pre><code>git clone https://github.com/bdfsaraiva/parshift\ncd parshift\npip install .\n</code></pre>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>For an in-depth overview of the features of ParShift can follow along  with one of the examples below:</p> Name Link Participation Shifts with ParShift"},{"location":"api/annotation.html","title":"<code>Annotation</code>","text":""},{"location":"api/annotation.html#parshift.annotation.read_ccsv","title":"<code>read_ccsv(filename, delimiter=',', quotechar='\"')</code>","text":"<p>Function used to read a conversation file and return a list of dictionary structure. The dictionary keys are: <code>id</code>, <code>user_id</code>, <code>message_text</code> and one of [<code>reply_id</code>, <code>target_id</code>].</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to csv file.</p> required <code>delimiter</code> <code>str</code> <p>Parameter delimiter.</p> <code>','</code> <code>quotechar</code> <code>str</code> <p>Parameter quotechar.</p> <code>'\"'</code> <p>Returns:</p> Name Type Description <code>conversation</code> <code>pd.DataFrame</code> <p>Pandas DataFrame.</p> Source code in <code>parshift/annotation.py</code> <pre><code>def read_ccsv(\n    filename: str, delimiter: str = \",\", quotechar: str = '\"'\n) -&gt; pd.DataFrame:\n\"\"\"Function used to read a conversation file and return a list of dictionary structure.\n    The dictionary keys are: `id`, `user_id`, `message_text` and one of [`reply_id`, `target_id`].\n\n    Arguments:\n        filename: Path to csv file.\n        delimiter: Parameter delimiter.\n        quotechar: Parameter quotechar.\n\n    Returns:\n        conversation: Pandas DataFrame.\n    \"\"\"\n\n    if not isinstance(filename, str):\n        raise TypeError(\"Parameter filename must be a String\")\n    if not re.search(\"^.*\\.csv$\", filename):\n        raise ValueError(\"Parameter filename must be a CSV file\")\n    if not isinstance(delimiter, str):\n        raise TypeError(\"Parameter delimiter must be a String\")\n    if len(delimiter) != 1:\n        raise ValueError(\"Parameter delimiter must be one character\")\n\n    conversation = []\n    with open(filename, \"r\", encoding=\"utf8\") as file:\n        csv_reader = csv.reader(file, delimiter=delimiter, quotechar=quotechar)\n        first_line_csv = list(csv_reader)[0]\n\n    if \"'reply_id'\" in first_line_csv or \"'target_id'\" in first_line_csv:\n        conversation = pd.read_csv(\n            filename, delimiter=delimiter, quotechar=quotechar, index_col=\"'id'\"\n        )\n        return conversation\n    else:\n        raise ValueError(\"CSV file must contain reply_id or target_id column\")\n</code></pre>"},{"location":"api/annotation.html#parshift.annotation.annotate","title":"<code>annotate(conversation_df)</code>","text":"<p>Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_df</code> <code>pd.DataFrame</code> <p>Pandas DataFrame.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee)</p> Source code in <code>parshift/annotation.py</code> <pre><code>def annotate(conversation_df: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        conversation_df: Pandas DataFrame.\n\n    Returns:\n        New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee)\n    \"\"\"\n\n    if not isinstance(conversation_df, pd.DataFrame):\n        print(type(conversation_df))\n        raise TypeError(\"Parameter conversation_df must be a Pandas DataFrame\")\n\n    conversation = _group_turns(conversation_df)\n\n    part_1 = \"\"\n    part_2 = \"\"\n\n    if \"'reply_id'\" in conversation_df.columns:\n        annotate_df = pd.DataFrame(\n            {\n                \"ids\": [],\n                \"user_id\": [],\n                \"message_text\": [],\n                \"reply_id\": [],\n                \"label_desc\": [],\n                \"pshift\": [],\n            }\n        )\n\n        for idx, msg in enumerate(conversation):\n            if (\n                msg[\"reply_id\"] == None\n                or msg[\"reply_id\"] == \"None\"\n                or msg[\"reply_id\"] == \"\"\n            ):\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n            else:\n                for msgPrev in conversation[: idx + 1]:\n                    if msg[\"reply_id\"] in msgPrev[\"ids\"]:\n                        if (\n                            msgPrev[\"reply_id\"] == None\n                            or msgPrev[\"reply_id\"] == \"None\"\n                            or msgPrev[\"reply_id\"] == \"\"\n                        ):\n                            part_1 = str(msgPrev[\"user_id\"]) + \" to group,\"\n\n                        else:  # reply - reply\n                            for msgPrev2 in conversation[:idx]:\n                                if msgPrev[\"reply_id\"] in msgPrev2[\"ids\"]:\n                                    part_1 = (\n                                        str(msgPrev[\"user_id\"])\n                                        + \" to \"\n                                        + str(msgPrev2[\"user_id\"])\n                                        + \",\"\n                                    )\n\n                        part_2 = (\n                            \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n                        )\n\n            p1p2 = part_1 + part_2\n            part_1 = part_2[1:] + \",\"\n            label_code_v = \"\"\n\n            if idx != 0:\n                msg[\"label\"] = p1p2\n                label_code_v = _pshift_code(p1p2)\n                msg[\"pshift\"] = label_code_v\n\n            annotate_df.loc[len(annotate_df.index)] = [\n                str(msg[\"ids\"]),\n                str(msg[\"user_id\"]),\n                msg[\"message_text\"],\n                str(msg[\"reply_id\"]),\n                p1p2,\n                label_code_v,\n            ]\n\n    elif \"'target_id'\" in conversation_df.columns:\n        annotate_df = pd.DataFrame(\n            {\n                \"ids\": [],\n                \"user_id\": [],\n                \"message_text\": [],\n                \"target_id\": [],\n                \"label_desc\": [],\n                \"pshift\": [],\n            }\n        )\n\n        for idx, msg in enumerate(conversation):\n            if (\n                msg[\"target_id\"] == None\n                or msg[\"target_id\"] == \"None\"\n                or msg[\"target_id\"] == \"\"\n            ):\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n            else:\n                msgPrev = conversation[idx - 1]\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n\n            p1p2 = part_1 + part_2\n            part_1 = part_2[1:] + \",\"\n\n            if idx != 0:\n                msg[\"label\"] = p1p2\n                label_code_v = _pshift_code(p1p2)\n                msg[\"pshift\"] = label_code_v\n\n            annotate_df.loc[len(annotate_df.index)] = [\n                str(msg[\"ids\"]),\n                str(msg[\"user_id\"]),\n                msg[\"message_text\"],\n                str(msg[\"target_id\"]),\n                (p1p2),\n                (label_code_v),\n            ]\n\n    annotate_df.drop(columns=[\"label_desc\"], inplace=True)\n\n    return annotate_df\n</code></pre>"},{"location":"api/annotation.html#parshift.annotation.pshift_type","title":"<code>pshift_type(pshift_code)</code>","text":"<p>Function used to return the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>pshift_code</code> <code>str</code> <p>Participation Shift Code (e.g A0-XA).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Participation shift type in a given turn - one of [Turn Receiving, Turn Claiming, Turn Usurping, Turn Continuing].</p> Source code in <code>parshift/annotation.py</code> <pre><code>def pshift_type(pshift_code: str) -&gt; str:\n\"\"\"Function used to return the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        pshift_code: Participation Shift Code (e.g A0-XA).\\n\n\n    Returns:\n        Participation shift type in a given turn - one of [Turn Receiving, Turn Claiming, Turn Usurping, Turn Continuing].\n    \"\"\"\n\n    if not isinstance(pshift_code, str):\n        raise TypeError(\"Parameter pshift_code must be a String\")\n    if not re.search(\"A[B|0]-[A|B|X][A|B|X|Y|0]\", pshift_code):\n        raise ValueError(\"Parameter pshift_code must be a parshift code. eg: AB-B0\")\n\n    return _p_shift_dict[pshift_code]\n</code></pre>"},{"location":"api/conditional_probabilities.html","title":"<code>Conditional Probabilities</code>","text":""},{"location":"api/conditional_probabilities.html#parshift.conditional_probabilities.conditional_probabilities","title":"<code>conditional_probabilities(parshift_annotation_df)</code>","text":"<p>Calculate the conditional probabilities for a given <code>parshift_annotation</code> DataFrame based on Gibson's framework.</p> <p>Parameters:</p> Name Type Description Default <code>parshift_annotation_df</code> <code>pd.DataFrame</code> <p>A DataFrame with <code>parshift</code> annotation. See here</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code. This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and those beginning with a directed one (AB-). CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup. CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences in each subgroup, assuming change of speaker.</p> Source code in <code>parshift/conditional_probabilities.py</code> <pre><code>def conditional_probabilities(parshift_annotation_df: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    Calculate the conditional probabilities for a given `parshift_annotation` DataFrame based on Gibson's framework.\n\n    Arguments:\n        parshift_annotation_df: A DataFrame with `parshift` annotation. See [here](https://bdfsaraiva.github.io/parshift/api/annotation.html#parshift.annotation.parshift_annotation)\n\n    Returns:\n        A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code.\n            This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and\n            those beginning with a directed one (AB-).\n            CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup.\n            CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences\n            in each subgroup, assuming change of speaker.\n    \"\"\"\n\n    if not isinstance(parshift_annotation_df, pd.DataFrame):\n        raise TypeError(\"Parameter parshift_annotation_df must be a Dataframe\")\n\n    frequency_table_and_counts = _frequency_table(parshift_annotation_df)\n    freq_table = frequency_table_and_counts[0]\n\n    cond_prob = {}\n    for key in freq_table:\n        if key.split(\"-\")[0] == \"A0\":\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[3], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": \"\",\n                }\n        else:\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[4], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": \"\",\n                }\n\n    cond_prob = pd.DataFrame.from_dict(cond_prob, orient=\"index\")\n    freq = pd.DataFrame.from_dict(freq_table, orient=\"index\", columns=[\"Frequency\"])\n    freq[\"Probability\"] = round(freq[\"Frequency\"] / freq[\"Frequency\"].sum(), 2)\n\n    result = (\n        pd.concat([freq, cond_prob], axis=1)\n        .reset_index()\n        .rename(columns={\"index\": \"pshift\"})\n    )\n\n    result = result.sort_values(\n        by=[\"pshift\"], key=lambda x: x.map(_cp_order)\n    ).reset_index(drop=True)\n\n    result_ordered = result.iloc[:, [0, 1, 2, 3, 4]]\n    return result_ordered\n</code></pre>"},{"location":"api/plotting.html","title":"<code>Plotting</code>","text":""},{"location":"api/plotting.html#parshift.plotting.frequency_treemap","title":"<code>frequency_treemap(conditional_probabilities_df, ax=None, column_name='pshift')</code>","text":"<p>Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>conditional_probabilities_df</code> <code>pd.DataFrame</code> <p>Dataframe object that contain the whole information about the Participation Shift conditional probabilities.</p> required <code>column_name</code> <code>str</code> <p>Column name to be used to plot the treemap. Must be one of the following: <code>pshift</code>, <code>pshift_type</code>.</p> <code>'pshift'</code> <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes to plot the treemap.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes with the Participation Shifts Frequency.</p> Source code in <code>parshift/plotting.py</code> <pre><code>def frequency_treemap(\n    conditional_probabilities_df: pd.DataFrame,\n    ax: matplotlib.axes.Axes = None,\n    column_name: str = \"pshift\",\n) -&gt; matplotlib.axes.Axes:\n\"\"\"Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.\n\n    Arguments:\n        conditional_probabilities_df: Dataframe object that contain the whole information about the Participation Shift conditional probabilities.\n        column_name: Column name to be used to plot the treemap. Must be one of the following: `pshift`, `pshift_type`.\n        ax: Matplotlib axes to plot the treemap.\n\n    Returns:\n        ax: Matplotlib axes with the Participation Shifts Frequency.\n    \"\"\"\n\n    if not isinstance(column_name, str):\n        raise TypeError(\"Parameter filename must be a String\")\n    if column_name not in [\"pshift_type\", \"pshift\"]:\n        raise ValueError(\n            \"Parameter column_name must be one of the following: `pshift`, `pshift_type`\"\n        )\n\n    if column_name == \"pshift_type\":\n        conditional_probabilities_df[\"pshift_type\"] = conditional_probabilities_df[\n            \"pshift\"\n        ].apply(pshift_type)\n\n    gb_parshift = conditional_probabilities_df.groupby([column_name])[\"Frequency\"].sum()\n\n    data = [\n        el\n        for el in list(zip(gb_parshift.values, gb_parshift.index.values))\n        if el[0] != 0\n    ]\n    labels = [\n        f\"{el} \\n {round( 100 * (list(zip(*data))[0][idx] / sum(list(list(zip(*data))[0]))),1)}%\"\n        for idx, el in enumerate(list(zip(*data))[1])\n    ]\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    squarify.plot(\n        list(zip(*data))[0],\n        label=labels,\n        pad=2,\n        color=sns.color_palette(\"Spectral\", len(list(zip(*data))[0])),\n        ax=ax,\n    )\n    plt.title(\"Participation Shifts Frequency (%)\")\n    plt.axis(\"off\")\n    # plt.show()\n    return ax\n</code></pre>"}]}