{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ParShift","text":"<p>ParShift is a python package based on Gibson's framework for the analysis of conversational sequences.</p> <p>The framework is established on the concept of participation shift, which refers to the shifting of individuals between the positions of speaker, target (addressee), and non-addressee (everyone else), in a group conversation.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#from-pypi","title":"From PyPI","text":"<pre><code>pip install parshift\n</code></pre>"},{"location":"#from-source","title":"From source","text":"<p>Directly using <code>pip</code>:</p> <pre><code>pip install git+https://github.com/bdfsaraiva/parshift.git#egg=parshift\n</code></pre> <p>Or each step at a time:</p> <pre><code>git clone https://github.com/bdfsaraiva/parshift\ncd parshift\npip install .\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For an in-depth overview of the features of ParShift can follow along with one of the examples below:</p> Name Link Participation Shifts with ParShift"},{"location":"#further-reading","title":"Further reading","text":"<ul> <li>Function reference</li> <li>Development reference</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"dev/","title":"Development","text":""},{"location":"dev/#installing-for-development-andor-improving-the-package","title":"Installing for development and/or improving the package","text":"<pre><code>$ git clone https://github.com/bdfsaraiva/parshift\n$ cd parshift\n$ python -m venv env\n$ source env/bin/activate\n$ pip install -e .[dev]\n</code></pre> <p>On Windows replace <code>source env/bin/activate</code> with <code>. env\\Scripts\\activate</code>.</p>"},{"location":"dev/#run-tests","title":"Run tests","text":"<p>Test can be run with the following command:</p> <pre><code>$ pytest\n</code></pre> <p>To generate an HTML page with coverage data, do the following:</p> <pre><code>$ pytest --cov=parshift --cov-report=html\n</code></pre> <p>Then open the generated <code>htmlcov/index.html</code> file in your browser to see the coverage HTML site.</p>"},{"location":"dev/#build-docs","title":"Build docs","text":"<p>Considering we're in the <code>parshift</code> project folder, run the following commands:</p> <pre><code>$ cd docs\n$ mkdocs build\n</code></pre> <p>The generated documentation will be placed in <code>docs/site</code>. Alternatively, the documentation can be generated and served locally with:</p> <pre><code>$ mkdocs serve\n</code></pre>"},{"location":"dev/#code-style","title":"Code style","text":"<p>ParShift's source code follows the black style.</p>"},{"location":"reference/","title":"Reference","text":"<p>API reference for the functions exported by ParShift.</p>"},{"location":"reference/#parshift.annotate","title":"annotate","text":"<pre><code>annotate(conv_df: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Get Gibson's participation shift codes from turns in a conversation.</p> <p>Sequences of messages from a speaker to the same addressee are considered to be in the same turn, and therefore will be assigned a single participation shift code.</p> <p>Parameters:</p> Name Type Description Default <code>conv_df</code> <code>pd.DataFrame</code> <p>The conversation from where to obtain the participation shift codes.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A dataframe with the participation shift codes for each turn.</p> Source code in <code>parshift/annotation.py</code> <pre><code>def annotate(conv_df: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Get Gibson's participation shift codes from turns in a conversation.\n\n    Sequences of messages from a speaker to the same addressee are considered to\n    be in the same turn, and therefore will be assigned a single participation\n    shift code.\n\n    Arguments:\n        conv_df: The conversation from where to obtain the participation shift codes.\n\n    Returns:\n        A dataframe with the participation shift codes for each turn.\n    \"\"\"\n\n    if not isinstance(conv_df, pd.DataFrame):\n        raise TypeError(\"Parameter conv_df must be a Pandas DataFrame\")\n\n    conversation = conv2turns(conv_df)\n\n    # part1 will take the parshift label for the previous turn\n    part_1 = \"\"\n\n    # part2 will take the parshift label for the current turn\n    part_2 = \"\"\n\n    if \"reply_id\" in conv_df.columns:\n        annotate_df = pd.DataFrame(\n            {\n                \"ids\": [],\n                \"user_id\": [],\n                \"message_text\": [],\n                \"reply_id\": [],\n                \"label_desc\": [],\n                \"pshift\": [],\n            }\n        )\n\n        # calculate the participation shift for each turn\n        for idx, msg in enumerate(conversation):\n            if (\n                msg[\"reply_id\"] == None\n                or msg[\"reply_id\"] == \"None\"\n                or msg[\"reply_id\"] == \"\"\n            ):\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n            else:\n                for msgPrev in conversation[: idx + 1]:\n                    if msg[\"reply_id\"] in msgPrev[\"ids\"]:\n                        if (\n                            msgPrev[\"reply_id\"] == None\n                            or msgPrev[\"reply_id\"] == \"None\"\n                            or msgPrev[\"reply_id\"] == \"\"\n                        ):\n                            part_1 = str(msgPrev[\"user_id\"]) + \" to group,\"\n\n                        else:  # reply - reply\n                            for msgPrev2 in conversation[:idx]:\n                                if msgPrev[\"reply_id\"] in msgPrev2[\"ids\"]:\n                                    part_1 = (\n                                        str(msgPrev[\"user_id\"])\n                                        + \" to \"\n                                        + str(msgPrev2[\"user_id\"])\n                                        + \",\"\n                                    )\n\n                        part_2 = (\n                            \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n                        )\n\n            # p1p2 takes the parshift label for the previous + current turn\n            p1p2 = part_1 + part_2\n\n            # part_1 takes the part_2 label for the next iteration\n            part_1 = part_2[1:] + \",\"\n\n            # set value to \"\" for first turn\n            pshift_label = \"\"\n\n            # we cannot calculate the pshift for the first turn\n            if idx != 0:\n                pshift_label = _pshift_code(p1p2)\n\n            annotate_df.loc[len(annotate_df.index)] = [  # type: ignore\n                str(msg[\"ids\"]),\n                str(msg[\"user_id\"]),\n                msg[\"message_text\"],\n                str(msg[\"reply_id\"]),\n                p1p2,\n                pshift_label,\n            ]\n\n    elif \"target_id\" in conv_df.columns:\n        annotate_df = pd.DataFrame(\n            {\n                \"ids\": [],\n                \"user_id\": [],\n                \"message_text\": [],\n                \"target_id\": [],\n                \"label_desc\": [],\n                \"pshift\": [],\n            }\n        )\n\n        # calculate the participation shift for each turn\n        for idx, msg in enumerate(conversation):\n            # if msg has no target, it is directed to the group\n            if (\n                msg[\"target_id\"] == None\n                or msg[\"target_id\"] == \"None\"\n                or msg[\"target_id\"] == \"\"\n            ):\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n\n            # if msg has a target, we save it\n            else:\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to \" + str(msg[\"target_id\"])\n\n            # p1p2 takes the parshift label for the previous + current turn\n            p1p2 = part_1 + part_2\n\n            # part_1 takes the part_2 label for the next iteration\n            part_1 = part_2[1:] + \",\"\n\n            # set value to \"\" for first turn\n            pshift_label = \"\"\n\n            # we cannot calculate the pshift for the first turn\n            if idx != 0:\n                msg[\"label\"] = p1p2\n                pshift_label = _pshift_code(p1p2)\n                msg[\"pshift\"] = pshift_label\n\n            annotate_df.loc[len(annotate_df.index)] = [  # type: ignore\n                str(msg[\"ids\"]),\n                str(msg[\"user_id\"]),\n                msg[\"message_text\"],\n                str(msg[\"target_id\"]),\n                p1p2,\n                pshift_label,\n            ]\n\n    annotate_df.drop(columns=[\"label_desc\"], inplace=True)\n\n    return annotate_df\n</code></pre>"},{"location":"reference/#parshift.cond_probs","title":"cond_probs","text":"<pre><code>cond_probs(pshift_codes: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Determine the conditional probabilities for a sequence of participation shift codes.</p> <p>Parameters:</p> Name Type Description Default <code>pshift_codes</code> <code>pd.DataFrame</code> <p>A sequence of participation shift code obtained with <code>annotate()</code>.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A dataframe containing the frequency, probability and conditional probabilities (two) for each parshift code. This dataframe is divided into two 'subgroups': (1) those beginning with an undirected remark (A0-); and, (2) those beginning with a directed one (AB-). The <code>CP</code> (conditional probability) column contains the frequency divided by total occurrences in each subgroup, while the <code>CPeTC</code> (Conditional Probability excluding Turn Continuing type) column contains the frequency divided by total occurrences in each subgroup, assuming change of speaker.</p> Source code in <code>parshift/statistics.py</code> <pre><code>def cond_probs(pshift_codes: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Determine the conditional probabilities for a sequence of participation shift codes.\n\n    Arguments:\n        pshift_codes: A sequence of participation shift code obtained with\n            [`annotate()`][parshift.annotation.annotate].\n\n    Returns:\n        A dataframe containing the frequency, probability and conditional probabilities\n            (two) for each parshift code. This dataframe is divided into two 'subgroups':\n            (1) those beginning with an undirected remark (A0-); and, (2) those beginning\n            with a directed one (AB-). The `CP` (conditional probability) column contains\n            the frequency divided by total occurrences in each subgroup, while the `CPeTC`\n            (Conditional Probability excluding Turn Continuing type) column contains the\n            frequency divided by total occurrences in each subgroup, assuming change of\n            speaker.\n    \"\"\"\n\n    if not isinstance(pshift_codes, pd.DataFrame):\n        raise TypeError(\"Parameter parshift_annotation_df must be a Dataframe\")\n\n    frequency_table_and_counts = _frequency_table(pshift_codes)\n    freq_table = frequency_table_and_counts[0]\n\n    cond_prob = {}\n    for key in freq_table:\n        if key.split(\"-\")[0] == \"A0\":\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[3], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": \"\",\n                }\n        else:\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[4], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": \"\",\n                }\n\n    cond_prob_df = pd.DataFrame.from_dict(cond_prob, orient=\"index\")\n    freq = pd.DataFrame.from_dict(freq_table, orient=\"index\", columns=[\"Frequency\"])\n    freq[\"Probability\"] = round(freq[\"Frequency\"] / freq[\"Frequency\"].sum(), 2)\n\n    result = (\n        pd.concat([freq, cond_prob_df], axis=1)\n        .reset_index()\n        .rename(columns={\"index\": \"pshift\"})\n    )\n\n    result = result.sort_values(\n        by=[\"pshift\"], key=lambda x: x.map(_cp_order)\n    ).reset_index(drop=True)\n\n    result_ordered = result.iloc[:, [0, 1, 2, 3, 4]]\n    return result_ordered\n</code></pre>"},{"location":"reference/#parshift.conv2turns","title":"conv2turns","text":"<pre><code>conv2turns(conv_df: pd.DataFrame) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Take a conversation dataframe and group it into conversation turns.</p> <p>A turn is a group of messages sent by the same user and addressed to the same target.</p> <p>Parameters:</p> Name Type Description Default <code>conv_df</code> <code>pd.DataFrame</code> <p>The conversation from where to obtain the conversation turns.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of dictionaries, each representing a conversation turn.</p> Source code in <code>parshift/annotation.py</code> <pre><code>def conv2turns(conv_df: pd.DataFrame) -&gt; List[Dict[str, Any]]:\n\"\"\"Take a conversation dataframe and group it into conversation turns.\n\n    A turn is a group of messages sent by the same user and addressed to the\n    same target.\n\n    Arguments:\n        conv_df: The conversation from where to obtain the conversation turns.\n\n    Returns:\n        A list of dictionaries, each representing a conversation turn.\n    \"\"\"\n\n    conv_df = conv_df.reset_index()\n    if \"reply_id\" in conv_df.columns:\n        last_col = \"reply_id\"\n    elif \"target_id\" in conv_df.columns:\n        last_col = \"target_id\"\n\n    conversation: List[Dict[str, Any]] = []\n    turn = 0\n\n    for index, row in conv_df.iterrows():\n        # If the row being looped has the same \"user_id\" and the \"last_col\" value,\n        # then merge the message text and message IDs into the previous turn.\n        if (\n            index != 0\n            and conversation[turn - 1][\"user_id\"] == row[\"user_id\"]\n            and str(conversation[turn - 1][last_col]) == row[last_col]\n        ):\n            msg_join = \". \".join(\n                [conversation[turn - 1][\"message_text\"], row[\"message_text\"]]\n            )\n            list_id = conversation[turn - 1][\"ids\"] + [row[\"id\"]]\n            conversation[turn - 1][\"ids\"] = list_id\n            conversation[turn - 1][\"message_text\"] = msg_join\n\n        # Otherwise, create a new dictionary representing a new turn\n        else:\n            id = row[\"id\"]\n            user_id = row[\"user_id\"]\n            message_text = row[\"message_text\"]\n            last_col_val = row[last_col]\n\n            conversation.append(\n                {\n                    \"ids\": [id],\n                    \"user_id\": user_id,\n                    \"message_text\": message_text,\n                    last_col: int(last_col_val) if last_col_val != \"None\" else None,\n                }\n            )\n\n            # Increment the turn counter\n            turn += 1\n\n    return conversation\n</code></pre>"},{"location":"reference/#parshift.frequency_treemap","title":"frequency_treemap","text":"<pre><code>frequency_treemap(\n    cond_probs_df: pd.DataFrame,\n    ax: matplotlib.axes.Axes = None,\n    column_name: str = \"pshift\",\n) -&gt; matplotlib.axes.Axes\n</code></pre> <p>Get a matplotlib axes object displaying the conditional probabilities or frequencies.</p> <p>Parameters:</p> Name Type Description Default <code>cond_probs_df</code> <code>pd.DataFrame</code> <p>Dataframe with information about the participation shift conditional probabilities. This dataframe can be obtained with <code>cond_probs()</code></p> required <code>column_name</code> <code>str</code> <p>Column name to be used to plot the treemap, either <code>\"pshift\"</code> (default) or <code>\"pshift_type\"</code>.</p> <code>'pshift'</code> <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes with the treemap plot.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes with the participation shifts probabilities or frequency.</p> Source code in <code>parshift/plotting.py</code> <pre><code>def frequency_treemap(\n    cond_probs_df: pd.DataFrame,\n    ax: matplotlib.axes.Axes = None,\n    column_name: str = \"pshift\",\n) -&gt; matplotlib.axes.Axes:\n\"\"\"Get a matplotlib axes object displaying the conditional probabilities or frequencies.\n\n    Arguments:\n        cond_probs_df: Dataframe with information about the participation shift\n            conditional probabilities. This dataframe can be obtained with\n            [`cond_probs()`][parshift.statistics.cond_probs]\n        column_name: Column name to be used to plot the treemap, either `\"pshift\"`\n            (default) or `\"pshift_type\"`.\n        ax: Matplotlib axes with the treemap plot.\n\n    Returns:\n        ax: Matplotlib axes with the participation shifts probabilities or frequency.\n    \"\"\"\n\n    if not isinstance(column_name, str):\n        raise TypeError(\"Parameter filename must be a String\")\n    if column_name not in [\"pshift_type\", \"pshift\"]:\n        raise ValueError(\n            \"Parameter column_name must be one of the following: `pshift`, `pshift_type`\"\n        )\n\n    if column_name == \"pshift_type\":\n        cond_probs_df[\"pshift_type\"] = cond_probs_df[\"pshift\"].apply(pshift_type)\n\n    gb_parshift = cond_probs_df.groupby([column_name])[\"Frequency\"].sum()\n\n    data = [\n        el\n        for el in list(zip(gb_parshift.values, gb_parshift.index.values))\n        if el[0] != 0\n    ]\n    labels = [\n        f\"{el} \\n {round( 100 * (list(zip(*data))[0][idx] / sum(list(list(zip(*data))[0]))),1)}%\"\n        for idx, el in enumerate(list(zip(*data))[1])\n    ]\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    squarify.plot(\n        list(zip(*data))[0],\n        label=labels,\n        pad=2,\n        color=sns.color_palette(\"Spectral\", len(list(zip(*data))[0])),\n        ax=ax,\n    )\n    plt.title(\"Participation Shifts Frequency (%)\")\n    plt.axis(\"off\")\n\n    return ax\n</code></pre>"},{"location":"reference/#parshift.pshift_type","title":"pshift_type","text":"<pre><code>pshift_type(pshift_code: str) -&gt; str\n</code></pre> <p>Returns the participation shift type given a participation shift code.</p> <p>Parameters:</p> Name Type Description Default <code>pshift_code</code> <code>str</code> <p>Participation shift code (e.g A0-XA).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Participation shift type in given the participation shift code (either \"Turn Receiving\", \"Turn Claiming\", \"Turn Usurping\" or  \"Turn Continuing\").</p> Source code in <code>parshift/annotation.py</code> <pre><code>def pshift_type(pshift_code: str) -&gt; str:\n\"\"\"Returns the participation shift type given a participation shift code.\n\n    Arguments:\n        pshift_code: Participation shift code (e.g A0-XA).\n\n    Returns:\n        Participation shift type in given the participation shift code (either\n            \"Turn Receiving\", \"Turn Claiming\", \"Turn Usurping\" or  \"Turn Continuing\").\n    \"\"\"\n\n    if not isinstance(pshift_code, str):\n        raise TypeError(\"Parameter pshift_code must be a String\")\n    if not re.search(\"A[B|0]-[A|B|X][A|B|X|Y|0]\", pshift_code):\n        raise ValueError(\"Parameter pshift_code must be a parshift code. eg: AB-B0\")\n\n    return _p_shift_dict[pshift_code]\n</code></pre>"},{"location":"reference/#parshift.read_ccsv","title":"read_ccsv","text":"<pre><code>read_ccsv(\n    filepath_or_buffer: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str],\n    **kwargs: Any\n) -&gt; pd.DataFrame\n</code></pre> <p>Read a conversation file in CSV format, validate it and return a dataframe.</p> <p>The conversation file should have the following columns:</p> <ul> <li><code>id</code>: ID of the message (int)</li> <li><code>user_id</code>: ID of the user sending the message (int)</li> <li><code>message_text</code>: The message itself (string)</li> <li><code>reply_id</code> or <code>target_id</code>: The reply ID or the target ID (int)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>filepath_or_buffer</code> <code>FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</code> <p>Any valid string path to CSV file, as accepted by Pandas <code>read_csv()</code> function.</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword parameters passed to Pandas <code>read_csv()</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A Pandas <code>DataFrame</code> containing the validated conversation.</p> Source code in <code>parshift/annotation.py</code> <pre><code>def read_ccsv(\n    filepath_or_buffer: FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str],\n    **kwargs: Any,\n) -&gt; pd.DataFrame:\n\"\"\"Read a conversation file in CSV format, validate it and return a dataframe.\n\n    The conversation file should have the following columns:\n\n    - `id`: ID of the message (int)\n    - `user_id`: ID of the user sending the message (int)\n    - `message_text`: The message itself (string)\n    - `reply_id` or `target_id`: The reply ID or the target ID (int)\n\n    Arguments:\n        filepath_or_buffer: Any valid string path to CSV file, as accepted by\n            Pandas [`read_csv()`][pandas.read_csv] function.\n        **kwargs: Keyword parameters passed to Pandas\n            [`read_csv()`][pandas.read_csv] function.\n\n    Returns:\n        A Pandas [`DataFrame`][pandas.DataFrame] containing the validated\n            conversation.\n    \"\"\"\n\n    # Read the conversation file\n    conversation: pd.DataFrame = pd.read_csv(filepath_or_buffer, dtype=_p_shift_cols, **kwargs)  # type: ignore\n\n    # Obtain potentially missing columns\n    missing = _p_shift_cols.keys() - conversation.columns\n\n    # Check if we have missing columns\n    if len(missing) == 1 and \"reply_id\" not in missing and \"target_id\" not in missing:\n        # If only one column missing, it can't be other than `reply_id` or `target_id`\n        raise ValueError(f\"CSV file is missing the `{missing.pop()}` column\")\n    elif len(missing) &gt; 1:\n        # If more than one column missing, we have a problem\n        raise ValueError(f\"CSV file is missing the `{'`, `'.join(missing)}` columns\")\n\n    return conversation\n</code></pre>"}]}