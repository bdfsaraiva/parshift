{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"ParShift","text":"<p>ParShift is a python package based on Gibson's framework for the analysis of conversational sequences.</p> <p>The framework is established on the concept of participation shift, which refers to the shifting of individuals between the positions of speaker, target (addressee), and non-addressee (everyone else), in a group conversation.</p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#from-pypi","title":"From PyPI","text":"<pre><code>pip install parshift #not available yet \n</code></pre>"},{"location":"index.html#from-source","title":"From source","text":"<p>Directly using pip:</p> <pre><code>pip install git+https://github.com/bdfsaraiva/parshift.git#egg=parshift\n</code></pre> <p>Or each step at a time:</p> <pre><code>git clone https://github.com/bdfsaraiva/parshift\ncd parshift\npip install .\n</code></pre>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>For an in-depth overview of the features of ParShift can follow along  with one of the examples below:</p> Name Link Participation Shifts with ParShift"},{"location":"api/annotation.html","title":"<code>Annotation</code>","text":""},{"location":"api/annotation.html#parshift.annotation.parshift_annotation","title":"<code>parshift_annotation(filename, delimiter=',', quotechar='\"')</code>","text":"<p>Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to csv file.</p> required <code>delimiter</code> <code>str</code> <p>Parameter delimiter.</p> <code>','</code> <code>quotechar</code> <code>str</code> <p>Parameter quotechar.</p> <code>'\"'</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee)</p> Source code in <code>parshift/annotation.py</code> <pre><code>def parshift_annotation(\n    filename: str, delimiter: str = \",\", quotechar: str = '\"'\n) -&gt; pd.DataFrame:\n\"\"\"Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        filename: Path to csv file.\n        delimiter: Parameter delimiter.\n        quotechar: Parameter quotechar.\n\n    Returns:\n        New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee)\n    \"\"\"\n\n    conversation = _read_conversation(filename, delimiter, quotechar)\n\n    df = pd.DataFrame(\n        {\n            \"ids\": [],\n            \"user_id\": [],\n            \"message_text\": [],\n            \"reply_id\": [],\n            \"label_desc\": [],\n            \"label_code\": [],\n            \"label_value\": [],\n        }\n    )\n\n    part_1 = \"\"\n    part_2 = \"\"\n    label_code_v = \"\"\n    label_type_v = \"\"\n\n    for idx, msg in enumerate(conversation):\n        if (\n            msg[\"reply_id\"] == None\n            or msg[\"reply_id\"] == \"None\"\n            or msg[\"reply_id\"] == \"\"\n        ):\n            part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n        else:\n            for msgPrev in conversation:\n                if msg[\"reply_id\"] in msgPrev[\"ids\"]:\n                    if (\n                        msgPrev[\"reply_id\"] == None\n                        or msgPrev[\"reply_id\"] == \"None\"\n                        or msgPrev[\"reply_id\"] == \"\"\n                    ):\n                        part_1 = str(msgPrev[\"user_id\"]) + \" to group,\"\n                    else:  # reply - reply\n                        for msgPrev2 in conversation:\n                            if msgPrev[\"reply_id\"] in msgPrev2[\"ids\"]:\n                                part_1 = (\n                                    str(msgPrev[\"user_id\"])\n                                    + \" to \"\n                                    + str(msgPrev2[\"user_id\"])\n                                    + \",\"\n                                )\n\n                    part_2 = (\n                        \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n                    )\n\n        p1p2 = part_1 + part_2\n        part_1 = part_2[1:] + \",\"\n\n        def _label_code(label):\n            # label split\n            a = label.split(\",\")[0].split(\"to\")[0].replace(\" \", \"\")\n            b = label.split(\",\")[0].split(\"to\")[1].replace(\" \", \"\")\n            c = label.split(\",\")[1].split(\"to\")[0].replace(\" \", \"\")\n            d = label.split(\",\")[1].split(\"to\")[1].replace(\" \", \"\")\n\n            # 1\n            result = \"A\"\n\n            # 2\n            result += \"0-\" if b == \"group\" else \"B-\"\n\n            # 3\n            if c == a:\n                result += \"A\"\n            elif c == b:\n                result += \"B\"\n            else:\n                result += \"X\"\n\n            # 4\n            if d == \"group\":\n                result += \"0\"\n            elif d == a:\n                result += \"A\"\n            elif d == b:\n                result += \"B\"\n            else:\n                result += \"Y\"\n\n            return result\n\n        if idx != 0:\n            msg[\"label\"] = p1p2\n            label_code_v = _label_code(p1p2)\n            msg[\"label_code\"] = label_code_v\n            label_type_v = _label_type(label_code_v)\n            msg[\"label_type\"] = label_type_v\n\n        df.loc[len(df.index)] = [\n            str(msg[\"ids\"]),\n            str(msg[\"user_id\"]),\n            msg[\"message_text\"],\n            str(msg[\"reply_id\"]),\n            (p1p2),\n            (label_code_v),\n            (label_type_v),\n        ]\n    df.drop(columns=[\"label_desc\"], inplace=True)\n    df.rename(\n        columns={\"label_code\": \"parshift_code\", \"label_value\": \"parshift\"}, inplace=True\n    )\n\n    return df\n</code></pre>"},{"location":"api/conditional_probabilities.html","title":"<code>Conditional Probabilities</code>","text":""},{"location":"api/conditional_probabilities.html#parshift.conditional_probabilities.conditional_probabilities","title":"<code>conditional_probabilities(parshift_annotation_df)</code>","text":"<p>Calculate the conditional probabilities for a given <code>parshift_annotation</code> DataFrame based on Gibson's framework.</p> <p>Parameters:</p> Name Type Description Default <code>parshift_annotation_df</code> <code>pd.DataFrame</code> <p>A DataFrame with <code>parshift</code> annotations. See here</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code. This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and those beginning with a directed one (AB-). CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup. CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences in each subgroup, assuming change of speaker.</p> Source code in <code>parshift/conditional_probabilities.py</code> <pre><code>def conditional_probabilities(parshift_annotation_df: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    Calculate the conditional probabilities for a given `parshift_annotation` DataFrame based on Gibson's framework.\n\n    Arguments:\n        parshift_annotation_df: A DataFrame with `parshift` annotations. See [here](https://bdfsaraiva.github.io/parshift/api/annotation.html#parshift.annotation.parshift_annotation)\n\n    Returns:\n        A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code.\n            This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and\n            those beginning with a directed one (AB-).\n            CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup.\n            CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences\n            in each subgroup, assuming change of speaker.\n    \"\"\"\n\n    if not isinstance(parshift_annotation_df, pd.DataFrame):\n        raise TypeError(\"Parameter parshift_annotation_df must be a Dataframe\")\n\n    frequency_table_and_counts = _frequency_table(parshift_annotation_df)\n    freq_table = frequency_table_and_counts[0]\n\n    cond_prob = {}\n    for key in freq_table:\n        if key.split(\"-\")[0] == \"A0\":\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[3], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": \"\",\n                }\n        else:\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[4], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": \"\",\n                }\n\n    cond_prob = pd.DataFrame.from_dict(cond_prob, orient=\"index\")\n    freq = pd.DataFrame.from_dict(freq_table, orient=\"index\", columns=[\"Frequency\"])\n    freq[\"Probability\"] = round(freq[\"Frequency\"] / freq[\"Frequency\"].sum(), 2)\n\n    result = (\n        pd.concat([freq, cond_prob], axis=1)\n        .reset_index()\n        .rename(columns={\"index\": \"parshift_code\"})\n    )\n    order = {\n        \"AB-BA\": 4,\n        \"AB-B0\": 5,\n        \"AB-BY\": 10,\n        \"A0-X0\": 1,\n        \"A0-XA\": 0,\n        \"A0-XY\": 2,\n        \"AB-X0\": 6,\n        \"AB-XA\": 7,\n        \"AB-XB\": 8,\n        \"AB-XY\": 11,\n        \"A0-AY\": 3,\n        \"AB-A0\": 9,\n        \"AB-AY\": 12,\n    }\n\n    result[\"parshift\"] = result[\"parshift_code\"].map(_label_type)\n    result = result.sort_values(\n        by=[\"parshift_code\"], key=lambda x: x.map(order)\n    ).reset_index(drop=True)\n\n    result_ordered = result.iloc[:, [0, 5, 1, 2, 3, 4]]\n    return result_ordered\n</code></pre>"},{"location":"api/plotting.html","title":"<code>Plotting</code>","text":""},{"location":"api/plotting.html#parshift.plotting.frequency_treemap","title":"<code>frequency_treemap(conditional_probabilities_df, ax=None, column_name='parshift')</code>","text":"<p>Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>conditional_probabilities_df</code> <code>pd.DataFrame</code> <p>Dataframe object that contain the whole information about the Participation Shift conditional probabilities.</p> required <code>column_name</code> <code>str</code> <p>Column name to be used to plot the treemap. Must be one of the following: <code>parshift_code</code>, <code>parshift</code>.</p> <code>'parshift'</code> <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes to plot the treemap.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes with the Participation Shifts Frequency.</p> Source code in <code>parshift/plotting.py</code> <pre><code>def frequency_treemap(\n    conditional_probabilities_df: pd.DataFrame,\n    ax: matplotlib.axes.Axes = None,\n    column_name: str = \"parshift\",\n) -&gt; matplotlib.axes.Axes:\n\"\"\"Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.\n\n    Arguments:\n        conditional_probabilities_df: Dataframe object that contain the whole information about the Participation Shift conditional probabilities.\n        column_name: Column name to be used to plot the treemap. Must be one of the following: `parshift_code`, `parshift`.\n        ax: Matplotlib axes to plot the treemap.\n\n    Returns:\n        ax: Matplotlib axes with the Participation Shifts Frequency.\n    \"\"\"\n\n    if not isinstance(column_name, str):\n        raise TypeError(\"Parameter filename must be a String\")\n    if column_name not in [\"parshift_code\", \"parshift\"]:\n        raise ValueError(\n            \"Parameter column_name must be one of the following: `parshift_code`, `parshift`\"\n        )\n\n    gb_parshift = conditional_probabilities_df.groupby([column_name])[\"Frequency\"].sum()\n\n    data = [\n        el\n        for el in list(zip(gb_parshift.values, gb_parshift.index.values))\n        if el[0] != 0\n    ]\n    labels = [\n        f\"{el} \\n {round( 100 * (list(zip(*data))[0][idx] / sum(list(list(zip(*data))[0]))),1)}%\"\n        for idx, el in enumerate(list(zip(*data))[1])\n    ]\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    squarify.plot(\n        list(zip(*data))[0],\n        label=labels,\n        pad=2,\n        color=sns.color_palette(\"Spectral\", len(list(zip(*data))[0])),\n        ax=ax,\n    )\n    plt.title(\"Participation Shifts Frequency (%)\")\n    plt.axis(\"off\")\n    # plt.show()\n    return ax\n</code></pre>"}]}