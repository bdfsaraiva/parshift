{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ParShift","text":"<p>ParShift is a python package based on Gibson's framework for the analysis of conversational sequences.</p> <p>The framework is established on the concept of participation shift, which refers to the shifting of individuals between the positions of speaker, target (addressee), and non-addressee (everyone else), in a group conversation.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#from-pypi","title":"From PyPI","text":"<pre><code>pip install parshift #not available yet \n</code></pre>"},{"location":"#from-source","title":"From source","text":"<p>Directly using pip:</p> <pre><code>pip install git+https://github.com/bdfsaraiva/parshift.git#egg=parshift\n</code></pre> <p>Or each step at a time:</p> <pre><code>git clone https://github.com/bdfsaraiva/parshift\ncd parshift\npip install .\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For an in-depth overview of the features of ParShift can follow along  with one of the examples below:</p> Name Link Participation Shifts with ParShift"},{"location":"api/annotation/","title":"<code>Annotation</code>","text":""},{"location":"api/annotation/#parshift.annotation.read_ccsv","title":"<code>read_ccsv(filename, **kwargs)</code>","text":"<p>Read a conversation file in CSV format, validate it and return a dataframe.</p> <p>The conversation file should have the following columns:</p> <ul> <li><code>id</code>: ID of the message (int)</li> <li><code>user_id</code>: ID of the user sending the message (int)</li> <li><code>message_text</code>: The message itself (string)</li> <li><code>reply_id</code> or <code>target_id</code>: The reply ID or the target ID (int)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to csv file.</p> required <code>**kwargs</code> <p>Keyword parameters passed to Pandas <code>read_csv()</code> function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>conversation</code> <code>pd.DataFrame</code> <p>Pandas DataFrame containing the validated conversation.</p> Source code in <code>parshift/annotation.py</code> <pre><code>def read_ccsv(filename: str, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Read a conversation file in CSV format, validate it and return a dataframe.\n\n    The conversation file should have the following columns:\n\n    - `id`: ID of the message (int)\n    - `user_id`: ID of the user sending the message (int)\n    - `message_text`: The message itself (string)\n    - `reply_id` or `target_id`: The reply ID or the target ID (int)\n\n    Arguments:\n        filename: Path to csv file.\n        **kwargs: Keyword parameters passed to Pandas\n            [`read_csv()`][pandas.read_csv] function.\n\n    Returns:\n        conversation: Pandas DataFrame containing the validated conversation.\n    \"\"\"\n\n    # Read the conversation file\n    conversation = pd.read_csv(filename, dtype=_p_shift_cols, **kwargs)\n\n    # Obtain potentially missing columns\n    missing = _p_shift_cols.keys() - conversation.columns\n\n    # Check if we have missing columns\n    if len(missing) == 1 and \"reply_id\" not in missing and \"target_id\" not in missing:\n        # If only one column missing, it can't be other than `reply_id` or `target_id`\n        raise ValueError(f\"CSV file is missing the `{missing.pop()}` column\")\n    elif len(missing) &gt; 1:\n        # If more than one column missing, we have a problem\n        raise ValueError(f\"CSV file is missing the `{'`, `'.join(missing)}` columns\")\n\n    return conversation\n</code></pre>"},{"location":"api/annotation/#parshift.annotation.annotate","title":"<code>annotate(conversation_df)</code>","text":"<p>Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_df</code> <code>pd.DataFrame</code> <p>Pandas DataFrame.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee)</p> Source code in <code>parshift/annotation.py</code> <pre><code>def annotate(conversation_df: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        conversation_df: Pandas DataFrame.\n\n    Returns:\n        New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee)\n    \"\"\"\n\n    if not isinstance(conversation_df, pd.DataFrame):\n        print(type(conversation_df))\n        raise TypeError(\"Parameter conversation_df must be a Pandas DataFrame\")\n\n    conversation = _group_turns(conversation_df)\n\n    part_1 = \"\"\n    part_2 = \"\"\n\n    if \"reply_id\" in conversation_df.columns:\n        annotate_df = pd.DataFrame(\n            {\n                \"ids\": [],\n                \"user_id\": [],\n                \"message_text\": [],\n                \"reply_id\": [],\n                \"label_desc\": [],\n                \"pshift\": [],\n            }\n        )\n\n        for idx, msg in enumerate(conversation):\n            if (\n                msg[\"reply_id\"] == None\n                or msg[\"reply_id\"] == \"None\"\n                or msg[\"reply_id\"] == \"\"\n            ):\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n            else:\n                for msgPrev in conversation[: idx + 1]:\n                    if msg[\"reply_id\"] in msgPrev[\"ids\"]:\n                        if (\n                            msgPrev[\"reply_id\"] == None\n                            or msgPrev[\"reply_id\"] == \"None\"\n                            or msgPrev[\"reply_id\"] == \"\"\n                        ):\n                            part_1 = str(msgPrev[\"user_id\"]) + \" to group,\"\n\n                        else:  # reply - reply\n                            for msgPrev2 in conversation[:idx]:\n                                if msgPrev[\"reply_id\"] in msgPrev2[\"ids\"]:\n                                    part_1 = (\n                                        str(msgPrev[\"user_id\"])\n                                        + \" to \"\n                                        + str(msgPrev2[\"user_id\"])\n                                        + \",\"\n                                    )\n\n                        part_2 = (\n                            \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n                        )\n\n            p1p2 = part_1 + part_2\n            part_1 = part_2[1:] + \",\"\n            label_code_v = \"\"\n\n            if idx != 0:\n                msg[\"label\"] = p1p2\n                label_code_v = _pshift_code(p1p2)\n                msg[\"pshift\"] = label_code_v\n\n            annotate_df.loc[len(annotate_df.index)] = [  # type: ignore\n                str(msg[\"ids\"]),\n                str(msg[\"user_id\"]),\n                msg[\"message_text\"],\n                str(msg[\"reply_id\"]),\n                p1p2,\n                label_code_v,\n            ]\n\n    elif \"target_id\" in conversation_df.columns:\n        annotate_df = pd.DataFrame(\n            {\n                \"ids\": [],\n                \"user_id\": [],\n                \"message_text\": [],\n                \"target_id\": [],\n                \"label_desc\": [],\n                \"pshift\": [],\n            }\n        )\n\n        for idx, msg in enumerate(conversation):\n            if (\n                msg[\"target_id\"] == None\n                or msg[\"target_id\"] == \"None\"\n                or msg[\"target_id\"] == \"\"\n            ):\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n            else:\n                msgPrev = conversation[idx - 1]\n                part_2 = \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n\n            p1p2 = part_1 + part_2\n            part_1 = part_2[1:] + \",\"\n\n            if idx != 0:\n                msg[\"label\"] = p1p2\n                label_code_v = _pshift_code(p1p2)\n                msg[\"pshift\"] = label_code_v\n\n            annotate_df.loc[len(annotate_df.index)] = [  # type: ignore\n                str(msg[\"ids\"]),\n                str(msg[\"user_id\"]),\n                msg[\"message_text\"],\n                str(msg[\"target_id\"]),\n                (p1p2),\n                (label_code_v),\n            ]\n\n    annotate_df.drop(columns=[\"label_desc\"], inplace=True)\n\n    return annotate_df\n</code></pre>"},{"location":"api/annotation/#parshift.annotation.pshift_type","title":"<code>pshift_type(pshift_code)</code>","text":"<p>Function used to return the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>pshift_code</code> <code>str</code> <p>Participation Shift Code (e.g A0-XA).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Participation shift type in a given turn - one of [Turn Receiving, Turn Claiming, Turn Usurping, Turn Continuing].</p> Source code in <code>parshift/annotation.py</code> <pre><code>def pshift_type(pshift_code: str) -&gt; str:\n\"\"\"Function used to return the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        pshift_code: Participation Shift Code (e.g A0-XA).\\n\n\n    Returns:\n        Participation shift type in a given turn - one of [Turn Receiving, Turn Claiming, Turn Usurping, Turn Continuing].\n    \"\"\"\n\n    if not isinstance(pshift_code, str):\n        raise TypeError(\"Parameter pshift_code must be a String\")\n    if not re.search(\"A[B|0]-[A|B|X][A|B|X|Y|0]\", pshift_code):\n        raise ValueError(\"Parameter pshift_code must be a parshift code. eg: AB-B0\")\n\n    return _p_shift_dict[pshift_code]\n</code></pre>"},{"location":"api/conditional_probabilities/","title":"<code>Conditional Probabilities</code>","text":""},{"location":"api/conditional_probabilities/#parshift.conditional_probabilities.conditional_probabilities","title":"<code>conditional_probabilities(parshift_annotation_df)</code>","text":"<p>Calculate the conditional probabilities for a given <code>parshift_annotation</code> DataFrame based on Gibson's framework.</p> <p>Parameters:</p> Name Type Description Default <code>parshift_annotation_df</code> <code>pd.DataFrame</code> <p>A DataFrame with <code>parshift</code> annotation. See here</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code. This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and those beginning with a directed one (AB-). CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup. CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences in each subgroup, assuming change of speaker.</p> Source code in <code>parshift/conditional_probabilities.py</code> <pre><code>def conditional_probabilities(parshift_annotation_df: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    Calculate the conditional probabilities for a given `parshift_annotation` DataFrame based on Gibson's framework.\n\n    Arguments:\n        parshift_annotation_df: A DataFrame with `parshift` annotation. See [here](https://bdfsaraiva.github.io/parshift/api/annotation.html#parshift.annotation.parshift_annotation)\n\n    Returns:\n        A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code.\n            This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and\n            those beginning with a directed one (AB-).\n            CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup.\n            CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences\n            in each subgroup, assuming change of speaker.\n    \"\"\"\n\n    if not isinstance(parshift_annotation_df, pd.DataFrame):\n        raise TypeError(\"Parameter parshift_annotation_df must be a Dataframe\")\n\n    frequency_table_and_counts = _frequency_table(parshift_annotation_df)\n    freq_table = frequency_table_and_counts[0]\n\n    cond_prob = {}\n    for key in freq_table:\n        if key.split(\"-\")[0] == \"A0\":\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[3], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": \"\",\n                }\n        else:\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[4], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": \"\",\n                }\n\n    cond_prob_df = pd.DataFrame.from_dict(cond_prob, orient=\"index\")\n    freq = pd.DataFrame.from_dict(freq_table, orient=\"index\", columns=[\"Frequency\"])\n    freq[\"Probability\"] = round(freq[\"Frequency\"] / freq[\"Frequency\"].sum(), 2)\n\n    result = (\n        pd.concat([freq, cond_prob_df], axis=1)\n        .reset_index()\n        .rename(columns={\"index\": \"pshift\"})\n    )\n\n    result = result.sort_values(\n        by=[\"pshift\"], key=lambda x: x.map(_cp_order)\n    ).reset_index(drop=True)\n\n    result_ordered = result.iloc[:, [0, 1, 2, 3, 4]]\n    return result_ordered\n</code></pre>"},{"location":"api/plotting/","title":"<code>Plotting</code>","text":""},{"location":"api/plotting/#parshift.plotting.frequency_treemap","title":"<code>frequency_treemap(conditional_probabilities_df, ax=None, column_name='pshift')</code>","text":"<p>Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>conditional_probabilities_df</code> <code>pd.DataFrame</code> <p>Dataframe object that contain the whole information about the Participation Shift conditional probabilities.</p> required <code>column_name</code> <code>str</code> <p>Column name to be used to plot the treemap. Must be one of the following: <code>pshift</code>, <code>pshift_type</code>.</p> <code>'pshift'</code> <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes to plot the treemap.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>matplotlib.axes.Axes</code> <p>Matplotlib axes with the Participation Shifts Frequency.</p> Source code in <code>parshift/plotting.py</code> <pre><code>def frequency_treemap(\n    conditional_probabilities_df: pd.DataFrame,\n    ax: matplotlib.axes.Axes = None,\n    column_name: str = \"pshift\",\n) -&gt; matplotlib.axes.Axes:\n\"\"\"Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.\n\n    Arguments:\n        conditional_probabilities_df: Dataframe object that contain the whole information about the Participation Shift conditional probabilities.\n        column_name: Column name to be used to plot the treemap. Must be one of the following: `pshift`, `pshift_type`.\n        ax: Matplotlib axes to plot the treemap.\n\n    Returns:\n        ax: Matplotlib axes with the Participation Shifts Frequency.\n    \"\"\"\n\n    if not isinstance(column_name, str):\n        raise TypeError(\"Parameter filename must be a String\")\n    if column_name not in [\"pshift_type\", \"pshift\"]:\n        raise ValueError(\n            \"Parameter column_name must be one of the following: `pshift`, `pshift_type`\"\n        )\n\n    if column_name == \"pshift_type\":\n        conditional_probabilities_df[\"pshift_type\"] = conditional_probabilities_df[\n            \"pshift\"\n        ].apply(pshift_type)\n\n    gb_parshift = conditional_probabilities_df.groupby([column_name])[\"Frequency\"].sum()\n\n    data = [\n        el\n        for el in list(zip(gb_parshift.values, gb_parshift.index.values))\n        if el[0] != 0\n    ]\n    labels = [\n        f\"{el} \\n {round( 100 * (list(zip(*data))[0][idx] / sum(list(list(zip(*data))[0]))),1)}%\"\n        for idx, el in enumerate(list(zip(*data))[1])\n    ]\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    squarify.plot(\n        list(zip(*data))[0],\n        label=labels,\n        pad=2,\n        color=sns.color_palette(\"Spectral\", len(list(zip(*data))[0])),\n        ax=ax,\n    )\n    plt.title(\"Participation Shifts Frequency (%)\")\n    plt.axis(\"off\")\n    # plt.show()\n    return ax\n</code></pre>"}]}