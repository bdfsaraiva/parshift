{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"ParShift","text":"<p>ParShift is a python package based on Gibson's framework for the analysis of conversational sequences.</p> <p>The framework is established on the concept of participation shift, which refers to the shifting of individuals between the positions of speaker, target (addressee), and non-addressee (everyone else), in a group conversation.</p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#from-pypi","title":"From PyPI","text":"<pre><code>pip install parshift #not available yet \n</code></pre>"},{"location":"index.html#from-source","title":"From source","text":"<p>Directly using pip:</p> <pre><code>pip install git+https://github.com/bdfsaraiva/parshift.git#egg=parshift\n</code></pre> <p>Or each step at a time:</p> <pre><code>git clone https://github.com/bdfsaraiva/parshift\ncd parshift\npip install .\n</code></pre>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>For an in-depth overview of the features of ParShift  you can check the full documentation or you can follow along  with one of the examples below:</p> Name Link Participation Shifts with ParSift"},{"location":"api/annotation.html","title":"<code>Annotation</code>","text":""},{"location":"api/annotation.html#parshift.annotation.parshift_annotation","title":"<code>parshift_annotation(filename, delimiter=',')</code>","text":"<p>Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path file name.</p> required <code>delimiter</code> <code>str</code> <p>Parameter delimiter.</p> <code>','</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee).</p> Source code in <code>parshift/annotation.py</code> <pre><code>def parshift_annotation(filename: str, delimiter: str = \",\") -&gt; pd.DataFrame:\n\n\"\"\"Function used to return a Dataframe which contains the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        filename: Path file name.\n        delimiter: Parameter delimiter.\n\n    Returns:\n        New Dataframe with Participation Shift label and type columns added for each turn (sequence of messages from a speaker to the same addressee).\n    \"\"\"\n\n    # # TODO: Adicionar o caso em que o usar j\u00e1 tem uma lista de sentences.\n    # if not filename and not conversation_list:\n    #     raise AssertionError(\"One of the parameters 'filename' or 'conversation_list' must be not None\")\n    # elif not conversation_list:\n    #     conversation = _read_conversation(filename, delimiter)\n    # else:\n    #     conversation = conversation_list\n    # # TODO: fim\n\n    conversation = _read_conversation(filename, delimiter)\n\n    df = pd.DataFrame(\n        {\n            \"id\": [],\n            \"user_id\": [],\n            \"message_text\": [],\n            \"reply_id\": [],\n            \"label_desc\": [],\n            \"label_code\": [],\n            \"label_value\": [],\n        }\n    )\n\n    part_1 = \"\"\n    part_2 = \"\"\n    label_code_v = \"\"\n    label_type_v = \"\"\n\n    for idx, msg in enumerate(conversation):\n\n        if (\n            msg[\"reply_id\"] == None\n            or msg[\"reply_id\"] == \"None\"\n            or msg[\"reply_id\"] == \"\"\n        ):\n            part_2 = \" \" + str(msg[\"user_id\"]) + \" to group\"\n        else:\n            for msgPrev in conversation:\n                if msg[\"reply_id\"] in msgPrev[\"id\"]:\n                    if (\n                        msgPrev[\"reply_id\"] == None\n                        or msgPrev[\"reply_id\"] == \"None\"\n                        or msgPrev[\"reply_id\"] == \"\"\n                    ):\n                        part_1 = str(msgPrev[\"user_id\"]) + \" to group,\"\n                    else:  # reply - reply\n                        for msgPrev2 in conversation:\n                            if msgPrev[\"reply_id\"] in msgPrev2[\"id\"]:\n                                part_1 = (\n                                    str(msgPrev[\"user_id\"])\n                                    + \" to \"\n                                    + str(msgPrev2[\"user_id\"])\n                                    + \",\"\n                                )\n\n                    part_2 = (\n                        \" \" + str(msg[\"user_id\"]) + \" to \" + str(msgPrev[\"user_id\"])\n                    )\n\n        p1p2 = part_1 + part_2\n        # print(part_1 + part_2)\n        part_1 = part_2[1:] + \",\"\n\n        def _label_code(label):\n            # label split\n            a = label.split(\",\")[0].split(\"to\")[0].replace(\" \", \"\")\n            b = label.split(\",\")[0].split(\"to\")[1].replace(\" \", \"\")\n            c = label.split(\",\")[1].split(\"to\")[0].replace(\" \", \"\")\n            d = label.split(\",\")[1].split(\"to\")[1].replace(\" \", \"\")\n\n            # 1\n            result = \"A\"\n\n            # 2\n            result += \"0-\" if b == \"group\" else \"B-\"\n\n            # 3\n            if c == a:\n                result += \"A\"\n            elif c == b:\n                result += \"B\"\n            else:\n                result += \"X\"\n\n            # 4\n            if d == \"group\":\n                result += \"0\"\n            elif d == a:\n                result += \"A\"\n            elif d == b:\n                result += \"B\"\n            else:\n                result += \"Y\"\n\n            return result\n\n        if idx != 0:\n            msg[\"label\"] = p1p2\n            label_code_v = _label_code(p1p2)\n            msg[\"label_code\"] = label_code_v\n            label_type_v = _label_type(label_code_v)\n            msg[\"label_type\"] = label_type_v\n\n        df.loc[len(df.index)] = [\n            str(msg[\"id\"]),\n            str(msg[\"user_id\"]),\n            msg[\"message_text\"],\n            str(msg[\"reply_id\"]),\n            (p1p2),\n            (label_code_v),\n            (label_type_v),\n        ]\n        # print('-'*20)\n    return df\n</code></pre>"},{"location":"api/annotation.html#parshift.annotation._read_conversation","title":"<code>_read_conversation(filename, delimiter=',')</code>","text":"<p>Function used to read a conversation file and return a list of dictionary structure. The dictionary keys are: <code>id</code>, <code>user_id</code>, <code>message_text</code> and <code>reply_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path file name.</p> required <code>delimiter</code> <code>str</code> <p>Parameter delimiter.</p> <code>','</code> <p>Returns:</p> Name Type Description <code>conversation</code> <code>list</code> <p>List of dictionary structure.</p> Source code in <code>parshift/annotation.py</code> <pre><code>def _read_conversation(filename: str, delimiter: str = \",\") -&gt; list:\n\"\"\"Function used to read a conversation file and return a list of dictionary structure.\n    The dictionary keys are: `id`, `user_id`, `message_text` and `reply_id`.\n\n    Arguments:\n        filename: Path file name.\n        delimiter: Parameter delimiter.\n\n    Returns:\n        conversation: List of dictionary structure.\n    \"\"\"\n\n    if not isinstance(filename, str):\n        raise TypeError(\"Parameter filename must be a String\")\n    if not re.search(\"^.*\\.csv$\", filename):\n        raise ValueError(\"Parameter filename must be a CSV file\")\n    if not isinstance(delimiter, str):\n        raise TypeError(\"Parameter delimiter must be a String\")\n    if len(delimiter) != 1:\n        raise ValueError(\"Parameter delimiter must be one character\")\n\n    conversation = []\n    with open(filename, \"r\", encoding=\"utf8\") as file:\n        csv_reader = csv.reader(file, delimiter=delimiter)\n\n        turn = 0\n        for idx, csv_line in enumerate(csv_reader):\n            if idx == 0:\n                continue  # header\n\n            if (\n                idx != 1\n                and conversation[turn - 1][\"user_id\"] == csv_line[1]\n                and conversation[turn - 1][\"reply_id\"] == csv_line[3]\n            ):\n                msg_join = f\"{conversation[turn-1]['message_text']}. {csv_line[2]}\"\n                list_id = conversation[turn - 1][\"id\"] + [csv_line[0]]\n                conversation[turn - 1][\"id\"] = list_id\n                conversation[turn - 1][\"message_text\"] = msg_join\n\n            else:\n                id = csv_line[0]\n                user_id = csv_line[1]\n                message_text = csv_line[2]\n                reply_id = csv_line[3]\n                turn += 1\n\n                conversation.append(\n                    {\n                        \"id\": [id],\n                        \"user_id\": user_id,\n                        \"message_text\": message_text,\n                        \"reply_id\": reply_id,\n                    }\n                )\n\n    return conversation\n</code></pre>"},{"location":"api/annotation.html#parshift.annotation._label_type","title":"<code>_label_type(label_code)</code>","text":"<p>Function used to return the Participation Shift type, based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>label_code</code> <code>str</code> <p>Participation Shift Code (e.g A0-XA).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Participation shift type in a given turn - one of [Turn Receiving, Turn Claiming, Turn Usurping, Turn Continuing].</p> Source code in <code>parshift/annotation.py</code> <pre><code>def _label_type(label_code: str) -&gt; str:\n\"\"\"Function used to return the Participation Shift type, based in Gibson's paper.\n\n    Arguments:\n        label_code: Participation Shift Code (e.g A0-XA).\\n\n\n    Returns:\n        Participation shift type in a given turn - one of [Turn Receiving, Turn Claiming, Turn Usurping, Turn Continuing].\n    \"\"\"\n\n    if not isinstance(label_code, str):\n        raise TypeError(\"Parameter label_code must be a String\")\n    if not re.search(\"A[B|0]-[A|B|X][A|B|X|Y|0]\", label_code):\n        raise ValueError(\"Parameter label_code must be a parshift code. eg: AB-B0\")\n\n    p_shift = {\n        \"AB-BA\": \"Turn Receiving\",\n        \"AB-B0\": \"Turn Receiving\",\n        \"AB-BY\": \"Turn Receiving\",\n        \"A0-X0\": \"Turn Claiming\",\n        \"A0-XA\": \"Turn Claiming\",\n        \"A0-XY\": \"Turn Claiming\",\n        \"AB-X0\": \"Turn Usurping\",\n        \"AB-XA\": \"Turn Usurping\",\n        \"AB-XB\": \"Turn Usurping\",\n        \"AB-XY\": \"Turn Usurping\",\n        \"A0-AY\": \"Turn Continuing\",\n        \"AB-A0\": \"Turn Continuing\",\n        \"AB-AY\": \"Turn Continuing\",\n        # \"A0-A0\": \"Turn Continuing\",\n    }\n    return p_shift[label_code]\n</code></pre>"},{"location":"api/conditional_probabilities.html","title":"<code>Conditional Probabilities</code>","text":""},{"location":"api/conditional_probabilities.html#parshift.conditional_probabilities.conditional_probabilities","title":"<code>conditional_probabilities(parshift_annotation_df)</code>","text":"<p>Calculate the conditional probabilities for a given <code>parshift_annotation</code> DataFrame based on Gibson's framework.</p> <p>Parameters:</p> Name Type Description Default <code>parshift_annotation_df</code> <code>pd.DataFrame</code> <p>A DataFrame with <code>parshift</code> annotations. See here</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code.  This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and  those beginning with a directed one (AB-).  CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup. CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences in each subgroup, assuming change of speaker.</p> Source code in <code>parshift/conditional_probabilities.py</code> <pre><code>def conditional_probabilities(parshift_annotation_df: pd.DataFrame) -&gt; pd.DataFrame:\n\n\"\"\"\n    Calculate the conditional probabilities for a given `parshift_annotation` DataFrame based on Gibson's framework.\n\n    Arguments:\n        parshift_annotation_df: A DataFrame with `parshift` annotations. See [here](https://bdfsaraiva.github.io/parshift/api/annotation.html#parshift.annotation.parshift_annotation)\n\n    Returns:\n        A DataFrame containing the frequency, probability and conditional probabilities (two) for each parshift code. \n            This DataFrame is divided into two 'subgroups', those beginning with an undirected remark (A0-) and \n            those beginning with a directed one (AB-). \n            CP (Conditional Probability) -&gt; Frequency divided by total occurrences in each subgroup.\n            CPeTC (Conditional Probability excluding Turn Continuing type) -&gt; Frequency divided by total occurrences\n            in each subgroup, assuming change of speaker.\n    \"\"\"\n\n    if not isinstance(parshift_annotation_df, pd.DataFrame):\n        raise TypeError(\"Parameter parshift_annotation_df must be a Dataframe\")\n\n    frequency_table_and_counts = _frequency_table(parshift_annotation_df)\n    freq_table = frequency_table_and_counts[0]\n\n    cond_prob = {}\n    for key in freq_table:\n        if key.split(\"-\")[0] == \"A0\":\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[3], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[1], 2),\n                    \"CPeTC\": \"\",\n                }\n        else:\n            if key not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": round(freq_table[key] / frequency_table_and_counts[4], 2),\n                }\n            else:\n                cond_prob[key] = {\n                    \"CP\": round(freq_table[key] / frequency_table_and_counts[2], 2),\n                    \"CPeTC\": \"\",\n                }\n\n    cond_prob = pd.DataFrame.from_dict(cond_prob, orient=\"index\")\n    freq = pd.DataFrame.from_dict(freq_table, orient=\"index\", columns=[\"Frequency\"])\n    freq[\"Probability\"] = round(freq[\"Frequency\"] / freq[\"Frequency\"].sum(), 2)\n\n    result = (\n        pd.concat([freq, cond_prob], axis=1)\n        .reset_index()\n        .rename(columns={\"index\": \"parshift_code\"})\n    )\n    order = {\n        \"AB-BA\": 5,\n        \"AB-B0\": 6,\n        \"AB-BY\": 11,\n        \"A0-X0\": 1,\n        \"A0-XA\": 0,\n        \"A0-XY\": 2,\n        \"AB-X0\": 7,\n        \"AB-XA\": 8,\n        \"AB-XB\": 9,\n        \"AB-XY\": 12,\n        \"A0-AY\": 3,\n        \"AB-A0\": 10,\n        \"AB-AY\": 12,\n        # \"A0-A0\": 4,\n    }\n\n    result[\"parshift\"] = result[\"parshift_code\"].map(_label_type)\n    result = result.sort_values(\n        by=[\"parshift_code\"], key=lambda x: x.map(order)\n    ).reset_index(drop=True)\n\n    return result\n</code></pre>"},{"location":"api/conditional_probabilities.html#parshift.conditional_probabilities._frequency_table","title":"<code>_frequency_table(parshift_annotation_df)</code>","text":"<p>This function takes in a dataframe of ParShift annotations and returns a frequency table of ParShift codes.</p> <p>Parameters:</p> Name Type Description Default <code>parshift_annotation_df</code> <p>A Pandas dataframe containing ParShift annotations</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list containing a dictionary of ParShift codes and their frequencies, the total number of times a ParShift code starting with \"A0\" appears, the total number of times a Parshift code starting with \"AB\" appears, the total number of times a Parshift code with \"A0\" assuming change of speaker, and the total number of times a ParShift code with \"AB\" appears assuming change of speaker.</p> Source code in <code>parshift/conditional_probabilities.py</code> <pre><code>def _frequency_table(parshift_annotation_df)-&gt; list:\n\"\"\"\n    This function takes in a dataframe of ParShift annotations and returns a frequency table of ParShift codes.\n\n    Arguments:\n        parshift_annotation_df: A Pandas dataframe containing ParShift annotations\n\n    Returns:\n        A list containing a dictionary of ParShift codes and their frequencies, the total number of times a ParShift code starting with \"A0\" appears,\n            the total number of times a Parshift code starting with \"AB\" appears, the total number of times a Parshift code with \"A0\" assuming change of\n            speaker, and the total number of times a ParShift code with \"AB\" appears assuming change of speaker.\n    \"\"\"\n\n    parshift_codes = [\n        \"AB-BA\",\n        \"AB-B0\",\n        \"AB-BY\",\n        \"A0-X0\",\n        \"A0-XA\",\n        \"A0-XY\",\n        \"AB-X0\",\n        \"AB-XA\",\n        \"AB-XB\",\n        \"AB-XY\",\n        \"A0-AY\",\n        \"AB-A0\",\n        \"AB-AY\",\n        # \"A0-A0\",\n    ]\n\n    dict_prob_empirical_count = {}\n    count_start_A0_total = 0\n    count_start_AB_total = 0\n    count_not_turn_continuing_A0 = 0\n    count_not_turn_continuing_AB = 0\n\n    for code in parshift_codes:\n        count = 0\n        for index, row in parshift_annotation_df.iterrows():\n            if row[\"label_code\"] == code:\n                count += 1\n\n        dict_prob_empirical_count[code] = count\n\n        if code.split(\"-\")[0] == \"A0\":\n            count_start_A0_total += count\n            if code not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                count_not_turn_continuing_A0 += count\n        else:\n            count_start_AB_total += count\n            if code not in [\"A0-AY\", \"AB-A0\", \"AB-AY\", \"A0-A0\"]:\n                count_not_turn_continuing_AB += count\n\n    return [\n        dict_prob_empirical_count,\n        count_start_A0_total,\n        count_start_AB_total,\n        count_not_turn_continuing_A0,\n        count_not_turn_continuing_AB,\n    ]\n</code></pre>"},{"location":"api/plotting.html","title":"<code>Plotting</code>","text":""},{"location":"api/plotting.html#parshift.plotting.frequency_treemap","title":"<code>frequency_treemap(conditional_probabilities_df)</code>","text":"<p>Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.</p> <p>Parameters:</p> Name Type Description Default <code>conditional_probabilities_df</code> <code>pd.DataFrame</code> <p>Dataframe object that contain the whole information about the Participation Shift conditional probabilities.</p> required <p>Returns:</p> Name Type Description <code>Figure</code> <p>Matplotlib object with the Participation Shifts Frequency.</p> Source code in <code>parshift/plotting.py</code> <pre><code>def frequency_treemap(conditional_probabilities_df: pd.DataFrame):\n\"\"\"Function used to return a matplotlib object which contains the conditional probabilities frequencies based in Gibson's paper.\n\n    Arguments:\n        conditional_probabilities_df: Dataframe object that contain the whole information about the Participation Shift conditional probabilities.\n\n    Returns:\n        Figure: Matplotlib object with the Participation Shifts Frequency.\n    \"\"\"\n\n    gb_parshift = conditional_probabilities_df.groupby([\"parshift\"])[\"Frequency\"].sum()\n\n    data = [\n        el\n        for el in list(zip(gb_parshift.values, gb_parshift.index.values))\n        if el[0] != 0\n    ]\n    labels = [\n        f\"{el} \\n {round( 100 * (list(zip(*data))[0][idx] / sum(list(list(zip(*data))[0]))),1)}%\"\n        for idx, el in enumerate(list(zip(*data))[1])\n    ]\n\n    figure = plt.figure()\n    squarify.plot(list(zip(*data))[0], label=labels, pad=2)\n    plt.title(\"Participation Shifts Frequency (%)\")\n    plt.axis(\"off\")\n    # plt.show()\n    return figure\n</code></pre>"}]}